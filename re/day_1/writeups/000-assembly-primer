Before we look at any programs, we need to cover a few topics that most of you won't know. If you know them, great! Sit tight, I'll make this quick :)

When looking at reverse engineering challenges, we first must be aware of the language of the program and whether that language is *compiled* or *interpreted*

Compiled languages are changed from human readable code such as this:
	for (int i = 0; i < 10; i++) {
		printf("Hi!\n");
	}

Into code that the machine (and more specifically, the processor) can run directly, such as this:
   0x0000000000001141 <+8>:     mov    DWORD PTR [rbp-0x4],0x0
   0x0000000000001148 <+15>:    jmp    0x115a <main+33>
   0x000000000000114a <+17>:    lea    rdi,[rip+0xeb3]        # 0x2004
   0x0000000000001151 <+24>:    call   0x1030 <puts@plt>
   0x0000000000001156 <+29>:    add    DWORD PTR [rbp-0x4],0x1
   0x000000000000115a <+33>:    cmp    DWORD PTR [rbp-0x4],0x9
   0x000000000000115e <+37>:    jle    0x114a <main+17>

Don't worry about understanding that code above yet! You'll learn as we go. But those two code snippets perform the *exact* same operation. One is written down in human-readable code called a high level langauge (in this case, C), and the second is written down in machine code called assembly. In this case, for the x86_64 architecture, which is what's in most modern computers. Compiled languages include languages like C, C++, Java, Fortran, and many many more.

Assembly is generated by a compiler, which is what enables programmers to write code in one language and have it run on many different types of computers. A compiler is just a program written for a specific architecture that takes high-level code and translates it into machine code for that architecture. They're stupidly complicated so don't worry about that part yet! We'll talk about how a compiler works later.

Interpreted languages, on the other hand, rely on someting called a ~surprise~ interpreter to run them. This interpreter is a program that runs programs and performs the actions within. Interpreted languages include languages like Python, PHP, Javascript, and more. The web loves interpreted languages!

The exact implementation differs, but in general if I write code like the following python:
	for i in range(100):
		print("hi!")

The python intepreter will simply follow that loop 100 times and print hi! for me.

We're going to concern ourselves mostly with compiled languages (the fun ones!).

Let's go back to that C code from before and include the rest of the program around it. 

#include <stdio.h>

int main() {
	for (int i = 0; i < 10; i++) {
		printf("Hi!\n")
	}
}

When we compile the program, we are actually performing many steps:
	-Preprocessor
	-Compiler
	-Assembler
	-Linker

First, preprocessing. We can see the preprocessor output with:
	gcc -E progname.c -o progname.p

I won't paste all the output because it's crazy long but basically the preprocessor copies in all the definitions it needs to run the program. That include means that we're going to copy in the external variables and function definitions from the <stdio.h> library. (Standard IO for y'all new folks). 

Next, the compiler. We can see the C code change to assembly code, but it's still in human-readable assembly format:
	gcc -S progname.c -o progname.s

        .file   "forloop.c"
        .text
        .section        .rodata
.LC0:
        .string "Hi!"
        .text
        .globl  main
        .type   main, @function
main:
.LFB0:
        .cfi_startproc
        pushq   %rbp
        .cfi_def_cfa_offset 16
        .cfi_offset 6, -16
        movq    %rsp, %rbp
        .cfi_def_cfa_register 6
        subq    $16, %rsp
        movl    $0, -4(%rbp)
        jmp     .L2
.L3:
        leaq    .LC0(%rip), %rdi
        call    puts@PLT
        addl    $1, -4(%rbp)
.L2:
        cmpl    $9, -4(%rbp)
        jle     .L3
        movl    $0, %eax
        leave
        .cfi_def_cfa 7, 8
        ret
        .cfi_endproc
.LFE0:
        .size   main, .-main
        .ident  "GCC: (GNU) 8.3.0"
        .section        .note.GNU-stack,"",@progbits

And finally the assembler, where we get a binary that isn't human readable but contains all the data and instructions that make up the program.

The linker is a little different from the other steps. You'll notice that the actual code for printf, which we use in our program, isn't actually *in* the assembly above. That's because the linker is set to link dynamically by default. When we run the program, the linker (ld on linux) will link the program to the standard library glibc, and when we call printf it will simply execute the printf function from that library and then return back to our code! This is very effcient because we can have far smaller executable sizes. 

We could also statically link the program, which would actually put the printf code into our program, but this is far less common. Pay attention to linking, because the standard library has many opportunities for exploits when we get around to that part of the bootcamp month.

Now that we've covered how machine code is generated, let's talk about that machine code. I'm only going to be showing code in Intel format because it's pretty, but there is also the AT&T format. Easy way to recognize AT&T: there are a ton of % symbols EVERYWHERE. 

First, let's talk about program structure.
Programs have several sections, not all of which are used all the time:
.text - Holds all the program's code.
.data - Holds any pre-defined variables and global scope variables.
.bss - Holds uninitialized data - Holds global and static variables that are initialized to zero or not initialized explicitly.
The following are not sections that exist in, say, an ELF file, but exist while the program is running:
heap - Holds dynamically allocated memory and variables.
stack - Holds local variables as they are created by the program. Notice that from here on out I'll say "top" and "bottom" of the stack frequently. The top of the stack is the LOWEST memory address and the bottom of the stack is the HIGHEST memory address. The stack grows from higher to lower memory.

And let's look at that all in a diagram:

+------------+
|   STACK    |
|            |
|     |      |
|     v      |
|            |
|    ...     |
|            |
|     ^      |
|     |      |
|            |
|   HEAP     |
+------------+
|   BSS      |
+------------+
|   DATA     |
+------------+
|   TEXT     |
+------------+

Notice that the stack and heap are not separated statically like the other sections. This is because typically the stack grows downards as the program is executed and the heap grows upwards towards the stack as more values are allocated. 

The stack is what is known as a LIFO, or Last In, First Out  data structure. Things are pushed onto the top and popped off the top of the stack.

Next, let's talk registers. Registers are small pieces of extremely fast hardware memory that hold values (or variables). Some are what's called general purpose and some are reserved for specific tasks. In the interest of space I'm only going to cover the x64 registers, because that's what I'm gonna teach. You can google the others. In fact, you can google anything. Please google lots, because I don't know everything. Also, this isn't all the registers, it's only some of them. I'm leaving off floating point and some specialty ones because frankly I don't know of anything that uses them much other than very particular software.

	RAX - General Purpose Register A
	RBX - General Purpose Register B
	RCX - General Purpose Register C
	RDX - General Purpose Register D
	RBP - Base Pointer Register
	RSP - Stack Pointer Register
	RSI - Source Index Register
	RDI - Destination Index Register
	R8 - General Purpose Register 8
	R9 - General Purpose Register 9
	R10 - General Purpose Register 10
	R11 - General Purpose Register 11
	R12 - General Purpose Register 12
	R13 - General Purpose Register 13
	R14 - General Purpose Register 14
	R15 - General Purpose Register 15


Some of these are important to know a little more about:
	RBP, the base pointer, points to the bottom of the stack. Therefore, items on the stack can be referenced by something like:
	[rbp-0x16]
	This would grab the value from the stack 0x16 bytes down from the base.

	RSP, the stack pointer, points to the top of the stack. This isn't used a ton on linux, but the windows compiler references most stack items by RSP, not by RBP. So it just depends.

	Additionally, when functions are called on linux, the first six arguments are passed in:
		RDI, RSI, RDX, RCX, R8, R9
	On windows, only the first 4 are passed in:
		RCX, RDX, R8, R9
	Any additonal arguments are passed on the stack. We'll look more at this when we look at code containing function calls.

	RAX, a general purpose register, but it will always contain the return value from a function. If you see instructions like this:
		call foo
		str rbp-0x8, rax

	You'll know they're storing the output of foo() onto the stack.

Now let's talk about function structure. Just as there are functions in high-level programming, there are functions in assembly. However instead of just writing:
	int x = getNumber();

There is a little more work that goes on behind the scenes when we're talking about assembly. Each time a function is called, something called a stack frame is created. The stack frame varies between compilers and architectures, but in general it is a "frame" that is pushed onto the program's call stack that contains information about the previous function that is calling our current function.

For example, we have a function:

void foo() {
	int a = 10;
	int b = 11;
	return;
}

With a stack frame that looks something like this on x86_64
+------------+
| arguments  |
+------------+
| saved RIP  |
+------------+
| saved FP   |
+------------+
| saved SP   |
+------------+
|     a      |
+------------+
|     b      |
+------------+

First, we have the saved return address. This is the address that, when a ret instruction is encountered, the instruction pointer will change to. Next, we have the base of the stack. This designates some local stack space for the current function where it can store its local variables. 

Each time a function is called, a new stack frame is created for that function and it is pushed onto the bottom of the call stack. Notice I said bottom, because recall the stack grows from the top down.

Below are some instructions you'll encounter in the demo programs. Note this is NOT an exhaustive list.

	mov <dst>, <src> - Moves the data from src to dst

	cmp <a>, <b> - Compares two pieces of data and sets flags accordingly

	lea <dst>, <src> - loads a pointer to src into dst

	push <a> - pushes a onto the stack

	pop <a> - pops the top of the stack into a

	add <a>, <b> - adds b to a and stores the value in a

	sub <a>, <b> - subtracts b from a and stores the value in a

	jmp <address> - Jumps to the code at <address> (there are a lot of types of jump)
	je - Jump if equal
	jz - Jump if zero
	jne - Jump if not equal
	jnz - Jump if not zero
	jg - Jump if greater
	jge - Jump if greater or equal
	jl - Jump if less
	jle - Jump if less or equal


